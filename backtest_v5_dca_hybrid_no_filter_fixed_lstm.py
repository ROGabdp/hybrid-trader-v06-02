# -*- coding: utf-8 -*-
"""
================================================================================
V5 DCA + AI Hybrid ç„¡æ¿¾ç¶² Fixed LSTM å›æ¸¬
(No Filter + Fixed LSTM Backtest)
================================================================================
çµåˆ DCA Hybrid ç­–ç•¥èˆ‡å›ºå®š LSTM æ¨¡å‹åŠŸèƒ½ã€‚
ä½¿ç”¨ V5 æ¨¡å‹ï¼ˆå°ç¨±çå‹µè¨“ç·´ï¼‰ï¼Œç„¡å”å…¶å®‰æ¿¾ç¶²é™åˆ¶ã€‚

**V5 æ¨¡å‹ç‰¹é»**:
- Buy Agent ä½¿ç”¨å°ç¨±çå‹µçµæ§‹è¨“ç·´
- ç„¡ Donchian æ¿¾ç¶²é™åˆ¶ï¼ŒAI å¯è‡ªç”±åˆ¤æ–·è²·å…¥æ™‚æ©Ÿ
- Sell Agent èˆ‡ V4 ç›¸åŒ

**Fixed LSTM ç‰¹é»**:
- é¦–æ¬¡åŸ·è¡Œæ™‚è¨“ç·´ LSTM ä¸¦å„²å­˜ç‚º _fixed ç‰ˆæœ¬
- å¾ŒçºŒåŸ·è¡Œæœƒè‡ªå‹•åµæ¸¬ä¸¦ä½¿ç”¨ç¾æœ‰çš„ _fixed æ¨¡å‹
- ä¿è­‰æ¯æ¬¡å›æ¸¬ä½¿ç”¨ç›¸åŒçš„ LSTMï¼Œçµæœå®Œå…¨ä¸€è‡´

LSTM è¨“ç·´è¨­å®šï¼š
- T+1:  éå» 2000 å¤©
- T+5:  éå» 2200 å¤©
- T+20: éå» 2400 å¤©
- split_ratio: 0.99 (å…¨é‡è¨“ç·´)

ä½œè€…ï¼šPhil Liang (Generated by Gemini)
æ—¥æœŸï¼š2025-12-27
================================================================================
"""

import os
import sys
import pickle
import argparse
import subprocess
import glob
from datetime import datetime, timedelta

# Windows UTF-8 è¨­å®š
if sys.platform == 'win32':
    sys.stdout.reconfigure(encoding='utf-8')

os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
from stable_baselines3 import PPO

# ä¸­æ–‡å­—å‹è¨­å®š
plt.rcParams['font.sans-serif'] = ['Microsoft JhengHei', 'SimHei', 'Arial Unicode MS']
plt.rcParams['axes.unicode_minus'] = False

# =============================================================================
# è¨­å®š
# =============================================================================
PROJECT_PATH = os.path.dirname(os.path.abspath(__file__))
V5_MODELS_PATH = os.path.join(PROJECT_PATH, 'models_hybrid_v5')
RESULTS_PATH = os.path.join(PROJECT_PATH, 'results_backtest_v5_dca_hybrid_no_filter_fixed_lstm')
CACHE_DIR = os.path.join(PROJECT_PATH, 'data', 'processed')

# [v6.0] LSTM å·²ç§»é™¤ - ä»¥ä¸‹è¨­å®šå·²åˆªé™¤:
# FIXED_LSTM_SUFFIX, SCRIPT_1D/5D/20D, TRAIN_DAYS_*, TRAIN_SPLIT_RATIO

DEFAULT_START_DATE = '2017-10-16'  # V6.02: é©—è­‰é›†èµ·å§‹æ—¥
DEFAULT_END_DATE = '2023-10-15'    # V6.02: é©—è­‰é›†çµæŸæ—¥
YEARLY_CAPITAL = 600_000  
MONTHLY_DCA_BENCHMARK = 50_000  


def parse_args():
    parser = argparse.ArgumentParser(
        description='V5 DCA + AI Hybrid No Filter Fixed LSTM Backtest',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument('--start', type=str, default=DEFAULT_START_DATE)
    parser.add_argument('--end', type=str, default=DEFAULT_END_DATE)
    parser.add_argument('--sell-threshold', type=float, default=0.5, help='Confidence threshold for sell signals')
    parser.add_argument('--buy-consensus-threshold', type=float, default=0.8, help='Buy confidence threshold to veto sell signals')
    return parser.parse_args()


# [v6.0] LSTM å·²ç§»é™¤ - ä»¥ä¸‹å‡½å¼å·²åˆªé™¤:
# - get_fixed_lstm_paths()
# - check_fixed_lstm_exists()  
# - train_and_save_fixed_lstm()
# - find_or_train_fixed_lstm()
# - load_fixed_lstm_models()
# - save_lstm_info()
















# =============================================================================
# Strategy 1: Shared Pool + 2x Leverage on Drawdown (å¤§è·Œæ™‚å•Ÿå‹•æ§“æ¡¿)
# =============================================================================
class LeveragedSharedPoolBacktester:
    """
    èˆ‡ Strategy 2 ç›¸åŒçš„ Shared Pool æ¶æ§‹ï¼Œä½†æ–°å¢ 2x æ§“æ¡¿åŠŸèƒ½ï¼š
    - ç•¶å¤§ç›¤å¾æ­·å²é«˜é»ä¸‹è·Œè¶…é 8% æ™‚ï¼Œå•Ÿå‹• 2x æ§“æ¡¿æ¨¡å¼ (èˆ‡åœæé»ä¸€è‡´)
    - åœ¨ 2x æ¨¡å¼æœŸé–“è²·å…¥çš„å€‰ä½ï¼ˆDCA å’Œ AI éƒ½é©ç”¨ï¼‰ï¼Œå…¶æ¼²è·Œå¹…ä»¥ 2 å€è¨ˆç®—
    - ç•¶å¤§ç›¤æ¼²å›åˆ°å•Ÿå‹• 2x æ¨¡å¼çš„é»ä½æ™‚ï¼ŒçµæŸ 2x æ¨¡å¼
    - å·²è²·å…¥çš„ 2x å€‰ä½ç¶­æŒ 2xï¼Œç›´åˆ°è©²å€‰ä½è¢«è³£å‡º
    """
    
    LEVERAGE_THRESHOLD = 0.08  # ä¸‹è·Œ 8% å•Ÿå‹•æ§“æ¡¿ (èˆ‡åœæé»ä¸€è‡´)
    
    def __init__(self, buy_model, sell_model, yearly_capital=600_000,
                 dca_amount=50_000, ai_chunk_amount=50_000,
                 sell_threshold=0.5, buy_consensus_threshold=0.8):
        self.buy_model = buy_model
        self.sell_model = sell_model
        self.yearly_capital = yearly_capital
        self.dca_amount = dca_amount
        self.ai_chunk_amount = ai_chunk_amount
        self.sell_threshold = sell_threshold
        self.buy_consensus_threshold = buy_consensus_threshold
        
        self.trades = []
        self.equity_curve = []
        self.dca_buy_signals = []      
        self.ai_buy_signals = []       
        self.ai_sell_signals = []
        self.filtered_signals = []
        self.daily_confidence = []
        self.daily_action_summary = []
        self.open_positions = []
        self.total_invested = 0
        
        # æ§“æ¡¿è¿½è¹¤
        self.leverage_events = []  # è¨˜éŒ„æ§“æ¡¿å•Ÿå‹•/çµæŸäº‹ä»¶
        self.leverage_periods = []  # è¨˜éŒ„æ§“æ¡¿æœŸé–“ (start_date, end_date)

    def run(self, df: pd.DataFrame, feature_cols: list) -> dict:
        features = df[feature_cols].values.astype(np.float32)
        close_prices = df['Close'].values
        dates = df.index
        
        # V5 ç„¡æ¿¾ç¶²æ¨¡å¼ - ä¸éœ€è¦è®€å– Signal_Buy_Filter
        
        # =========== å‹•æ…‹è³‡é‡‘åˆ†é… ===========
        # yearly_pool: ç•¶å¹´åº¦å¯ç”¨è³‡é‡‘æ±  (åŒ…å«å¹´åˆæ³¨å…¥ + AI è³£å‡ºå›æ”¶)
        # æ¯æœˆè²·å…¥é‡‘é¡ = yearly_pool / å‰©é¤˜æœˆæ•¸
        yearly_pool = 0
        dca_positions = []
        ai_positions = []
        
        current_year = None
        last_dca_month = None
        dynamic_chunk_amount = self.dca_amount  # å‹•æ…‹è¨ˆç®—çš„å–®ç­†è²·å…¥é‡‘é¡
        
        # 2x æ§“æ¡¿è¿½è¹¤
        leveraged_mode = False
        leverage_trigger_price = 0
        peak_price = close_prices[0]
        current_leverage_start = None
        
        print(f"[Strategy 1] Period: {dates[0].strftime('%Y-%m-%d')} ~ {dates[-1].strftime('%Y-%m-%d')}")
        print(f"[Strategy 1] Dynamic Fund Allocation + 2x Leverage on Drawdown")
        print(f"[Strategy 1] Leverage Threshold: -{self.LEVERAGE_THRESHOLD*100:.0f}% from peak")
        print(f"[Strategy 1] MODE: NO FILTER (V5 å°ç¨±çå‹µ)")
        
        for i in range(len(df)):
            date = dates[i]
            price = close_prices[i]
            year = date.year
            month = date.month
            
            # =========== 2x æ§“æ¡¿é‚è¼¯ ===========
            if not leveraged_mode:
                peak_price = max(peak_price, price)
            
            if not leveraged_mode:
                if price < peak_price * (1 - self.LEVERAGE_THRESHOLD):
                    leveraged_mode = True
                    leverage_trigger_price = price
                    current_leverage_start = date
                    self.leverage_events.append({
                        'date': date, 'event': 'START', 'price': price,
                        'peak_price': peak_price, 
                        'drawdown': (peak_price - price) / peak_price * 100
                    })
                    print(f"  ğŸ”¥ [{date.strftime('%Y-%m-%d')}] 2x æ§“æ¡¿å•Ÿå‹•! åƒ¹æ ¼ {price:,.0f} (å¾é«˜é» {peak_price:,.0f} ä¸‹è·Œ {(peak_price-price)/peak_price*100:.1f}%)")
            else:
                if price >= leverage_trigger_price:
                    leveraged_mode = False
                    self.leverage_events.append({
                        'date': date, 'event': 'END', 'price': price,
                        'trigger_price': leverage_trigger_price
                    })
                    self.leverage_periods.append((current_leverage_start, date))
                    print(f"  âœ… [{date.strftime('%Y-%m-%d')}] 2x æ§“æ¡¿çµæŸ! åƒ¹æ ¼ {price:,.0f} (å›åˆ°è§¸ç™¼é» {leverage_trigger_price:,.0f})")
                    peak_price = price
                    current_leverage_start = None
            
            current_leverage = 2.0 if leveraged_mode else 1.0
            # =========== End æ§“æ¡¿é‚è¼¯ ===========
            
            # =========== å¹´åº¦è³‡é‡‘æ³¨å…¥ ===========
            if current_year != year:
                current_year = year
                last_dca_month = None
                # å¹´åˆæ³¨å…¥æ–°è³‡é‡‘åˆ°æ± ä¸­
                yearly_pool += self.yearly_capital
                self.total_invested += self.yearly_capital
                # è¨ˆç®—å‰©é¤˜æœˆæ•¸ (1æœˆ=12å€‹æœˆ, 12æœˆ=1å€‹æœˆ)
                remaining_months = 13 - month
                dynamic_chunk_amount = yearly_pool / remaining_months if remaining_months > 0 else yearly_pool
                print(f"  [{year}] +${self.yearly_capital:,.0f} â†’ Pool: ${yearly_pool:,.0f}, å‰©é¤˜{remaining_months}æœˆ, æ¯å€‰: ${dynamic_chunk_amount:,.0f}")

            # =========== å‹•æ…‹è¨ˆç®—æ¯æœˆè²·å…¥é‡‘é¡ ===========
            # æ¯æœˆåˆé‡æ–°è¨ˆç®— (åŒ…å« AI è³£å‡ºå›æ”¶çš„è³‡é‡‘)
            if last_dca_month != month:
                remaining_months = 13 - month  # 1æœˆæœ‰12å€‹æœˆ, 12æœˆæœ‰1å€‹æœˆ
                if remaining_months > 0 and yearly_pool > 0:
                    dynamic_chunk_amount = yearly_pool / remaining_months
                else:
                    dynamic_chunk_amount = yearly_pool
                # ç¢ºä¿æœ€ä½è²·å…¥é‡‘é¡
                dynamic_chunk_amount = max(dynamic_chunk_amount, 10000)  # æœ€ä½ 1 è¬

            # =========== DCA (Monthly) ===========
            day_dca_shares = 0
            day_dca_leverage = 1.0
            if last_dca_month != month:
                last_dca_month = month
                # å¾æ± ä¸­åˆ†é…è³‡é‡‘
                fund = min(dynamic_chunk_amount, yearly_pool)
                if fund > price:  # è‡³å°‘èƒ½è²· 1 è‚¡
                    yearly_pool -= fund
                    shares = int(fund / price)
                    cost = shares * price
                    leftover = fund - cost
                    yearly_pool += leftover  # é›¶é ­æ”¾å›æ± ä¸­
                    
                    dca_positions.append({
                        'shares': shares, 
                        'buy_price': price, 
                        'buy_idx': i, 
                        'cost': cost,
                        'leverage': current_leverage
                    })
                    day_dca_shares = shares
                    day_dca_leverage = current_leverage
                    self.dca_buy_signals.append((date, price, shares, current_leverage))
            
            # AI
            obs = np.nan_to_num(features[i], nan=0.0, posinf=1.0, neginf=-1.0)
            
            # ç•¶æ—¥è¿½è¹¤è®Šæ•¸
            day_action = 'HOLD'
            day_buy_conf = None
            day_sell_conf = None
            day_note = ''
            day_sold_count = 0
            day_bought_shares = 0
            day_ai_leverage = 1.0
            
            # ğŸ”¥ Agent Consensus: æ¯æ—¥å¿…é ˆå–å¾— Buy Agent çš„ä¿¡å¿ƒåº¦ (ç„¡è«–æ˜¯å¦æœ‰éŒ¢è²·)
            # ç”¨æ–¼åˆ¤æ–·å¸‚å ´è¶¨å‹¢ï¼Œè‹¥æ¥µåº¦çœ‹å¥½ (Conf > buy_consensus_threshold) å‰‡å¦æ±ºè³£å‡º
            current_obs = obs.reshape(1, -1)
            buy_action_pred, _ = self.buy_model.predict(current_obs, deterministic=True)
            buy_probs = self.buy_model.policy.get_distribution(self.buy_model.policy.obs_to_tensor(current_obs)[0]).distribution.probs.detach().cpu().numpy()[0]
            current_buy_conf = float(buy_probs[1]) if buy_action_pred[0] == 1 else float(buy_probs[0])
            day_buy_conf = current_buy_conf
            
            # æª¢æŸ¥æŒå€‰è³£å‡º (AI positions)
            max_sell_conf_today = 0
            for idx in range(len(ai_positions) - 1, -1, -1):
                pos = ai_positions[idx]
                hold_days = i - pos['buy_idx']
                
                # è¨ˆç®—æ§“æ¡¿å¾Œçš„å ±é…¬ç‡ (ç”¨æ–¼ sell agent observation)
                base_return = price / pos['buy_price']
                leveraged_return = 1 + (base_return - 1) * pos['leverage']
                
                sell_obs = np.concatenate([obs, [leveraged_return]]).astype(np.float32).reshape(1, -1)
                action, _ = self.sell_model.predict(sell_obs, deterministic=True)
                
                sell_probs = self.sell_model.policy.get_distribution(self.sell_model.policy.obs_to_tensor(sell_obs)[0]).distribution.probs.detach().cpu().numpy()[0]
                sell_conf = float(sell_probs[1]) if action[0] == 1 else float(sell_probs[0])
                max_sell_conf_today = max(max_sell_conf_today, sell_conf)
                
                log_entry = {'date': date, 'status': 'holding', 'price': price, 'sell_conf': sell_conf, 'buy_conf': current_buy_conf, 'action': 'hold', 'leverage': pos['leverage']}
                self.daily_confidence.append(log_entry)
                
                # è³£å‡ºæ¢ä»¶ï¼š(AI æ±ºå®šè³£å‡º ä¸” ç„¡å…±è­˜å¦æ±º) æˆ– æ§“æ¡¿å¾Œå ±é…¬ < 0.92 (å¼·åˆ¶åœæ)
                # å…±è­˜å¦æ±ºï¼šå¦‚æœ Sell Conf > Threshold (æƒ³è³£) ä½† Buy Conf > Consensus Threshold (æ¥µåº¦çœ‹å¤š)ï¼Œå‰‡ HOLD
                
                is_stop_loss = leveraged_return < 0.92
                # ä½¿ç”¨åƒæ•¸åŒ–çš„ sell_threshold (default 0.5)
                is_sell_signal = (action[0] == 1 and sell_conf > self.sell_threshold)
                
                # å…±è­˜æª¢æŸ¥
                is_consensus_hold = False
                if is_sell_signal and not is_stop_loss:
                    if current_buy_conf > self.buy_consensus_threshold:
                        is_consensus_hold = True
                        # print(f"  ğŸ›‘ [{date.strftime('%Y-%m-%d')}] Sell Vetoed! SellConf:{sell_conf:.2f} but BuyConf:{current_buy_conf:.2f}")

                if (is_sell_signal and not is_consensus_hold) or is_stop_loss:
                    log_entry['action'] = 'SELL'
                    if is_stop_loss:
                        log_entry['sell_reason'] = 'stop_loss'
                    else:
                        log_entry['sell_reason'] = 'ai_signal'
                    # è¨ˆç®—å¯¦éš›æ”¶ç›Š (è€ƒæ…®æ§“æ¡¿)
                    leveraged_value = pos['cost'] * leveraged_return
                    profit = leveraged_value - pos['cost']
                    # ğŸ”¥ è³£å‡ºæ”¶ç›Šå›åˆ° yearly_poolï¼Œå¯ç”¨æ–¼å¾ŒçºŒè²·å…¥
                    yearly_pool += leveraged_value
                    
                    self.trades.append({
                        'type': 'AI_S1', 
                        'return': leveraged_return - 1, 
                        'base_return': base_return - 1,
                        'profit': profit, 
                        'hold_days': hold_days,
                        'leverage': pos['leverage']
                    })
                    self.ai_sell_signals.append({'date': date, 'price': price, 'confidence': sell_conf, 'leverage': pos['leverage']})
                    ai_positions.pop(idx)
                    day_action = 'SELL'
                    day_sell_conf = sell_conf
                    day_sold_count += 1

            # æª¢æŸ¥è²·å…¥ (ç„¡æ¿¾ç¶² - V5 æ¨¡å¼)
            
            # è¨˜éŒ„æª¢æŸ¥è²·å…¥ç‹€æ…‹
            if yearly_pool < dynamic_chunk_amount or dynamic_chunk_amount < price:
                 log_entry = {'date': date, 'status': 'check_buy', 'price': price, 'buy_conf': current_buy_conf, 'action': 'wait', 'leverage': current_leverage}
                 self.daily_confidence.append(log_entry)

            # ğŸ”¥ ä½¿ç”¨å‹•æ…‹è¨ˆç®—çš„è²·å…¥é‡‘é¡
            if yearly_pool >= dynamic_chunk_amount and dynamic_chunk_amount > price:
                # å·²ç¶“åœ¨ä¸Šé¢è¨ˆç®—é current_buy_conf
                
                log_entry = {'date': date, 'status': 'check_buy', 'price': price, 'buy_conf': current_buy_conf, 'action': 'wait', 'leverage': current_leverage}
                self.daily_confidence.append(log_entry)

                if buy_action_pred[0] == 1:
                    # AI æƒ³è²· - ç›´æ¥è²·å…¥ï¼Œç„¡æ¿¾ç¶²æª¢æŸ¥
                    fund = min(dynamic_chunk_amount, yearly_pool)
                    if fund > price:
                        yearly_pool -= fund
                        log_entry['action'] = 'BUY'
                        shares = int(fund / price)
                        cost = shares * price
                        leftover = fund - cost
                        yearly_pool += leftover  # é›¶é ­æ”¾å›æ± ä¸­
                        ai_positions.append({
                            'shares': shares, 
                            'buy_price': price, 
                            'buy_idx': i, 
                            'cost': cost,
                            'leverage': current_leverage
                        })
                        self.ai_buy_signals.append({'date': date, 'price': price, 'confidence': current_buy_conf, 'leverage': current_leverage})
                        day_action = 'BUY'
                        day_bought_shares = shares
                        day_ai_leverage = current_leverage
            
            # ç”¢ç”Ÿç•¶æ—¥æ‘˜è¦
            dca_position_count = len(dca_positions)
            notes = []
            
            if day_dca_shares > 0:
                lev_str = f"({day_dca_leverage:.0f}x)" if day_dca_leverage > 1 else ""
                notes.append(f'DCA+1å€‰{lev_str}')
            if day_sold_count > 0:
                notes.append(f'AI-{day_sold_count}å€‰')
            if day_bought_shares > 0:
                lev_str = f"({day_ai_leverage:.0f}x)" if day_ai_leverage > 1 else ""
                notes.append(f'AI+1å€‰{lev_str}')
            
            # è¨ˆç®— 2x å€‰æ•¸
            dca_2x_count = sum(1 for p in dca_positions if p['leverage'] > 1)
            ai_2x_count = sum(1 for p in ai_positions if p['leverage'] > 1)
            total_positions = dca_position_count + len(ai_positions)
            total_2x = dca_2x_count + ai_2x_count
            
            lev_status = "ğŸ”¥2x" if leveraged_mode else ""
            notes.append(f'ç¾{total_positions}å€‰(DCA{dca_position_count}+AI{len(ai_positions)})[2x:{total_2x}]{lev_status}')
            
            day_note = ', '.join(notes)
            
            if day_sell_conf is None and len(ai_positions) > 0:
                day_sell_conf = max_sell_conf_today if max_sell_conf_today > 0 else None
            
            self.daily_action_summary.append({
                'date': date,
                'ai_action': day_action,
                'price': price,
                'ai_buy_conf': day_buy_conf,
                'ai_sell_conf': day_sell_conf,
                'ai_position_count': len(ai_positions),
                'dca_position_count': dca_position_count,
                'total_position_count': total_positions,
                'leveraged_mode': leveraged_mode,
                'current_leverage': current_leverage,
                'positions_2x': total_2x,
                'note': day_note
            })

            # è¨ˆç®—ç¸½å¸‚å€¼ (è€ƒæ…®æ§“æ¡¿)
            dca_val = sum(
                p['cost'] * (1 + (price / p['buy_price'] - 1) * p['leverage'])
                for p in dca_positions
            )
            ai_val = sum(
                p['cost'] * (1 + (price / p['buy_price'] - 1) * p['leverage'])
                for p in ai_positions
            )
            total_val = dca_val + ai_val + yearly_pool
            
            self.equity_curve.append({'date': date, 'value': total_val, 'leveraged_mode': leveraged_mode})
        
        # å¦‚æœå›æ¸¬çµæŸæ™‚é‚„åœ¨æ§“æ¡¿æ¨¡å¼ï¼Œè¨˜éŒ„æœªçµæŸçš„æœŸé–“
        if leveraged_mode and current_leverage_start:
            self.leverage_periods.append((current_leverage_start, dates[-1]))
        
        # ä¿å­˜æœªå¹³å€‰æŒå€‰
        self.open_positions = []
        for pos in ai_positions:
            self.open_positions.append({
                'buy_date': dates[pos['buy_idx']].strftime('%Y-%m-%d'),
                'buy_price': pos['buy_price'],
                'shares': pos['shares'],
                'cost': pos['cost'],
                'leverage': pos['leverage']
            })
            
        return self._calculate_metrics()

    def _calculate_metrics(self) -> dict:
        if not self.equity_curve: return {}
        equity_df = pd.DataFrame(self.equity_curve).set_index('date')
        final = equity_df['value'].iloc[-1]
        total_return = (final - self.total_invested) / self.total_invested if self.total_invested > 0 else 0
        days = (equity_df.index[-1] - equity_df.index[0]).days
        annualized = (1 + total_return) ** (365/days) - 1 if days > 0 else 0
        daily_ret = equity_df['value'].pct_change().fillna(0)
        sharpe = (daily_ret.mean() * 252) / (daily_ret.std() * np.sqrt(252)) if daily_ret.std() > 0 else 0
        roll_max = equity_df['value'].cummax()
        max_dd = ((equity_df['value'] - roll_max) / roll_max).min()
        
        wins = sum(1 for t in self.trades if t['return'] > 0)
        win_rate = wins / len(self.trades) if self.trades else 0
        
        # æ§“æ¡¿çµ±è¨ˆ
        leverage_2x_buys = sum(1 for s in self.ai_buy_signals if s.get('leverage', 1) > 1)
        leverage_2x_buys += sum(1 for s in self.dca_buy_signals if len(s) > 3 and s[3] > 1)
        
        return {
            'total_invested': self.total_invested,
            'final_value': final,
            'total_return': total_return,
            'annualized_return': annualized,
            'sharpe_ratio': sharpe,
            'max_drawdown': max_dd,
            'total_trades': len(self.trades),
            'win_rate': win_rate,
            'equity_df': equity_df,
            'dca_buys': len(self.dca_buy_signals),
            'ai_buys': len(self.ai_buy_signals),
            'leverage_events': len(self.leverage_events),
            'leverage_2x_buys': leverage_2x_buys,
            'leverage_periods': self.leverage_periods
        }


# =============================================================================
# Strategy 2: Shared Pool (Injection Mode) - WITH FILTER
# =============================================================================
class SharedPoolBacktester:
    def __init__(self, buy_model, sell_model, yearly_capital=600_000, 
                 dca_amount=50_000, ai_chunk_amount=50_000,
                 sell_threshold=0.5, buy_consensus_threshold=0.8):
        self.buy_model = buy_model
        self.sell_model = sell_model
        self.yearly_capital = yearly_capital
        self.dca_amount = dca_amount
        self.ai_chunk_amount = ai_chunk_amount
        self.sell_threshold = sell_threshold
        self.buy_consensus_threshold = buy_consensus_threshold
        
        self.trades = []
        self.equity_curve = []
        self.dca_buy_signals = []      
        self.ai_buy_signals = []       
        self.ai_sell_signals = []
        self.filtered_signals = []     # AIæƒ³è²·ä½†è¢«æ¿¾ç¶²æ“‹ä¸‹çš„è¨Šè™Ÿ
        self.daily_confidence = []
        self.daily_action_summary = []  # æ¯æ—¥æ“ä½œæ‘˜è¦ (ä¸€å¤©ä¸€ç­†)
        self.open_positions = []       # å›æ¸¬çµæŸæ™‚çš„æœªå¹³å€‰ AI æŒå€‰
        self.total_invested = 0

    def run(self, df: pd.DataFrame, feature_cols: list) -> dict:
        features = df[feature_cols].values.astype(np.float32)
        close_prices = df['Close'].values
        dates = df.index
        
        # V5 ç„¡æ¿¾ç¶²æ¨¡å¼ - ä¸éœ€è¦è®€å– Signal_Buy_Filter
        
        # =========== å‹•æ…‹è³‡é‡‘åˆ†é… ===========
        # yearly_pool: ç•¶å¹´åº¦å¯ç”¨è³‡é‡‘æ±  (åŒ…å«å¹´åˆæ³¨å…¥ + AI è³£å‡ºå›æ”¶)
        # æ¯æœˆè²·å…¥é‡‘é¡ = yearly_pool / å‰©é¤˜æœˆæ•¸
        yearly_pool = 0
        dca_shares = 0
        ai_positions = []      
        
        current_year = None
        last_dca_month = None
        dynamic_chunk_amount = self.dca_amount  # å‹•æ…‹è¨ˆç®—çš„å–®ç­†è²·å…¥é‡‘é¡
        
        print(f"[Strategy 2] Period: {dates[0].strftime('%Y-%m-%d')} ~ {dates[-1].strftime('%Y-%m-%d')}")
        print(f"[Strategy 2] Shared Pool (Dynamic Fund Allocation)")
        print(f"[Strategy 2] MODE: NO FILTER (V5 å°ç¨±çå‹µ)")
        
        for i in range(len(df)):
            date = dates[i]
            price = close_prices[i]
            year = date.year
            month = date.month
            
            # =========== å¹´åº¦è³‡é‡‘æ³¨å…¥ ===========
            if current_year != year:
                current_year = year
                last_dca_month = None
                # å¹´åˆæ³¨å…¥æ–°è³‡é‡‘åˆ°æ± ä¸­
                yearly_pool += self.yearly_capital
                self.total_invested += self.yearly_capital
                # è¨ˆç®—å‰©é¤˜æœˆæ•¸ (1æœˆ=12å€‹æœˆ, 12æœˆ=1å€‹æœˆ)
                remaining_months = 13 - month
                dynamic_chunk_amount = yearly_pool / remaining_months if remaining_months > 0 else yearly_pool
                print(f"  [{year}] +${self.yearly_capital:,.0f} â†’ Pool: ${yearly_pool:,.0f}, å‰©é¤˜{remaining_months}æœˆ, æ¯å€‰: ${dynamic_chunk_amount:,.0f}")

            # =========== å‹•æ…‹è¨ˆç®—æ¯æœˆè²·å…¥é‡‘é¡ ===========
            # æ¯æœˆåˆé‡æ–°è¨ˆç®— (åŒ…å« AI è³£å‡ºå›æ”¶çš„è³‡é‡‘)
            if last_dca_month != month:
                remaining_months = 13 - month  # 1æœˆæœ‰12å€‹æœˆ, 12æœˆæœ‰1å€‹æœˆ
                if remaining_months > 0 and yearly_pool > 0:
                    dynamic_chunk_amount = yearly_pool / remaining_months
                else:
                    dynamic_chunk_amount = yearly_pool
                # ç¢ºä¿æœ€ä½è²·å…¥é‡‘é¡
                dynamic_chunk_amount = max(dynamic_chunk_amount, 10000)  # æœ€ä½ 1 è¬

            # =========== DCA (Monthly) ===========
            day_dca_shares = 0  # ç•¶æ—¥ DCA è²·å…¥è‚¡æ•¸
            if last_dca_month != month:
                last_dca_month = month
                # å¾æ± ä¸­åˆ†é…è³‡é‡‘
                fund = min(dynamic_chunk_amount, yearly_pool)
                if fund > price:  # è‡³å°‘èƒ½è²· 1 è‚¡
                    yearly_pool -= fund
                    shares = int(fund / price)
                    cost = shares * price
                    leftover = fund - cost
                    yearly_pool += leftover  # é›¶é ­æ”¾å›æ± ä¸­
                    
                    dca_shares += shares
                    day_dca_shares = shares
                    self.dca_buy_signals.append((date, price, shares))
            
            # AI
            obs = np.nan_to_num(features[i], nan=0.0, posinf=1.0, neginf=-1.0)
            
            # ç•¶æ—¥è¿½è¹¤è®Šæ•¸
            day_action = 'HOLD'
            day_buy_conf = None
            day_sell_conf = None
            day_note = ''
            day_sold_count = 0
            day_bought_shares = 0
            
            # ğŸ”¥ Agent Consensus: æ¯æ—¥å¿…é ˆå–å¾— Buy Agent çš„ä¿¡å¿ƒåº¦
            current_obs = obs.reshape(1, -1)
            buy_action_pred, _ = self.buy_model.predict(current_obs, deterministic=True)
            buy_probs = self.buy_model.policy.get_distribution(self.buy_model.policy.obs_to_tensor(current_obs)[0]).distribution.probs.detach().cpu().numpy()[0]
            current_buy_conf = float(buy_probs[1]) if buy_action_pred[0] == 1 else float(buy_probs[0])
            day_buy_conf = current_buy_conf
            
            # æª¢æŸ¥æŒå€‰è³£å‡º
            max_sell_conf_today = 0
            for idx in range(len(ai_positions) - 1, -1, -1):
                pos = ai_positions[idx]
                hold_days = i - pos['buy_idx']
                current_return = price / pos['buy_price']
                sell_obs = np.concatenate([obs, [current_return]]).astype(np.float32).reshape(1, -1)
                action, _ = self.sell_model.predict(sell_obs, deterministic=True)
                
                sell_probs = self.sell_model.policy.get_distribution(self.sell_model.policy.obs_to_tensor(sell_obs)[0]).distribution.probs.detach().cpu().numpy()[0]
                sell_conf = float(sell_probs[1]) if action[0] == 1 else float(sell_probs[0])
                max_sell_conf_today = max(max_sell_conf_today, sell_conf)
                
                log_entry = {'date': date, 'status': 'holding', 'price': price, 'sell_conf': sell_conf, 'buy_conf': current_buy_conf, 'action': 'hold'}
                self.daily_confidence.append(log_entry)
                
                is_stop_loss = current_return < 0.92
                is_sell_signal = (action[0] == 1 and sell_conf > self.sell_threshold)
                
                # å…±è­˜æª¢æŸ¥
                is_consensus_hold = False
                if is_sell_signal and not is_stop_loss:
                    if current_buy_conf > self.buy_consensus_threshold:
                        is_consensus_hold = True

                if (is_sell_signal and not is_consensus_hold) or is_stop_loss:
                    log_entry['action'] = 'SELL'
                    proceeds = pos['shares'] * price
                    profit = proceeds - pos['cost']
                    # ğŸ”¥ è³£å‡ºæ”¶ç›Šå›åˆ° yearly_poolï¼Œå¯ç”¨æ–¼å¾ŒçºŒè²·å…¥
                    yearly_pool += proceeds 
                    self.trades.append({'type': 'AI_S2', 'return': current_return - 1, 'profit': profit, 'hold_days': hold_days})
                    self.ai_sell_signals.append({'date': date, 'price': price, 'confidence': sell_conf})
                    ai_positions.pop(idx)
                    day_action = 'SELL'
                    day_sell_conf = sell_conf
                    day_sold_count += 1

            # æª¢æŸ¥è²·å…¥ (ç„¡æ¿¾ç¶² - V5 æ¨¡å¼)
            
            if yearly_pool < dynamic_chunk_amount or dynamic_chunk_amount < price:
                 log_entry = {'date': date, 'status': 'check_buy', 'price': price, 'buy_conf': current_buy_conf, 'action': 'wait'}
                 self.daily_confidence.append(log_entry)

            # ğŸ”¥ ä½¿ç”¨å‹•æ…‹è¨ˆç®—çš„è²·å…¥é‡‘é¡
            if yearly_pool >= dynamic_chunk_amount and dynamic_chunk_amount > price:
                # å·²ç¶“åœ¨ä¸Šé¢è¨ˆç®—é current_buy_conf
                
                log_entry = {'date': date, 'status': 'check_buy', 'price': price, 'buy_conf': current_buy_conf, 'action': 'wait'}
                self.daily_confidence.append(log_entry)

                if buy_action_pred[0] == 1:
                    # AI æƒ³è²· - ç›´æ¥è²·å…¥ï¼Œç„¡æ¿¾ç¶²æª¢æŸ¥
                    fund = min(dynamic_chunk_amount, yearly_pool)
                    if fund > price:
                        yearly_pool -= fund
                        log_entry['action'] = 'BUY'
                        shares = int(fund / price)
                        cost = shares * price
                        leftover = fund - cost
                        yearly_pool += leftover  # é›¶é ­æ”¾å›æ± ä¸­
                        ai_positions.append({'shares': shares, 'buy_price': price, 'buy_idx': i, 'cost': cost})
                        self.ai_buy_signals.append({'date': date, 'price': price, 'confidence': current_buy_conf})
                        day_action = 'BUY'
                        day_bought_shares = shares
            
            # ç”¢ç”Ÿç•¶æ—¥æ‘˜è¦ - æ ¼å¼: DCAè²·è³£, AIè²·è³£, ç¸½å€‰æ•¸
            # DCA è¦–ç‚ºæ¯æœˆè²·1å€‰ (50k), AI æ¯ç­†è²·1å€‰ (50k)
            dca_position_count = len(self.dca_buy_signals)  # DCAè²·å…¥æ¬¡æ•¸=DCAå€‰æ•¸
            notes = []
            
            # åˆ†åˆ¥è¿½è¹¤ DCAã€AIè³£å‡ºã€AIè²·å…¥ (ä¸ç”¨ day_actionï¼Œé¿å…è¢«è¦†è“‹)
            if day_dca_shares > 0:
                notes.append('DCA+1å€‰')
            if day_sold_count > 0:
                notes.append(f'AI-{day_sold_count}å€‰')
            if day_bought_shares > 0:
                notes.append('AI+1å€‰')
            
            # ç¸½å€‰æ•¸ = DCAå€‰ + AIå€‰
            total_positions = dca_position_count + len(ai_positions)
            notes.append(f'ç¾{total_positions}å€‰(DCA{dca_position_count}+AI{len(ai_positions)})')
            
            day_note = ', '.join(notes)
            
            # å¦‚æœæ²’æœ‰è²·é€²ä½†æœ‰æª¢æŸ¥è²·å…¥ï¼Œè¨˜éŒ„è²·å…¥ä¿¡å¿ƒ
            if day_sell_conf is None and len(ai_positions) > 0:
                day_sell_conf = max_sell_conf_today if max_sell_conf_today > 0 else None
            
            self.daily_action_summary.append({
                'date': date,
                'ai_action': day_action,
                'price': price,
                'ai_buy_conf': day_buy_conf,
                'ai_sell_conf': day_sell_conf,
                'ai_position_count': len(ai_positions),
                'dca_position_count': dca_position_count,
                'total_position_count': total_positions,
                'note': day_note
            })

            # Value = Stock + Yearly Pool
            dca_val = dca_shares * price
            ai_val = sum(p['shares'] * price for p in ai_positions)
            total_val = dca_val + ai_val + yearly_pool
            
            self.equity_curve.append({'date': date, 'value': total_val})
        
        # ä¿å­˜æœªå¹³å€‰æŒå€‰ (ç”¨æ–¼ intraday è…³æœ¬è®€å–)
        self.open_positions = []
        for pos in ai_positions:
            self.open_positions.append({
                'buy_date': dates[pos['buy_idx']].strftime('%Y-%m-%d'),
                'buy_price': pos['buy_price'],
                'shares': pos['shares'],
                'cost': pos['cost']
            })
            
        return self._calculate_metrics()

    def _calculate_metrics(self) -> dict:
        if not self.equity_curve: return {}
        equity_df = pd.DataFrame(self.equity_curve).set_index('date')
        final = equity_df['value'].iloc[-1]
        total_return = (final - self.total_invested) / self.total_invested if self.total_invested > 0 else 0
        days = (equity_df.index[-1] - equity_df.index[0]).days
        annualized = (1 + total_return) ** (365/days) - 1 if days > 0 else 0
        daily_ret = equity_df['value'].pct_change().fillna(0)
        sharpe = (daily_ret.mean() * 252) / (daily_ret.std() * np.sqrt(252)) if daily_ret.std() > 0 else 0
        roll_max = equity_df['value'].cummax()
        max_dd = ((equity_df['value'] - roll_max) / roll_max).min()
        
        wins = sum(1 for t in self.trades if t['return'] > 0)
        win_rate = wins / len(self.trades) if self.trades else 0
        return {
            'total_invested': self.total_invested,
            'final_value': final,
            'total_return': total_return,
            'annualized_return': annualized,
            'sharpe_ratio': sharpe,
            'max_drawdown': max_dd,
            'total_trades': len(self.trades),
            'win_rate': win_rate,
            'equity_df': equity_df,
            'dca_buys': len(self.dca_buy_signals),
            'ai_buys': len(self.ai_buy_signals)
        }


def calculate_pure_dca(df: pd.DataFrame, monthly_amount: float = 50_000):
    close_prices = df['Close'].values
    dates = df.index
    shares = 0
    total_invested = 0
    equity_curve = []
    last_month = None
    leftover_cash = 0  # ç´¯ç©çš„é›¶é ­
    current_year = None
    
    for i in range(len(df)):
        date = dates[i]
        price = close_prices[i]
        year = date.year
        month = date.month
        
        # å¹´åº¦è®Šæ›´ - é‡ç½® leftover (æ–°å¹´åº¦é–‹å§‹)
        if current_year != year:
            current_year = year
            leftover_cash = 0  # æ–°å¹´åº¦é–‹å§‹ï¼Œé‡ç½®é›¶é ­æ± 
        
        if last_month != month:
            last_month = month
            # æ­£å¸¸æœˆæŠ•å…¥
            fund = monthly_amount
            shares_to_buy = int(fund / price)
            if shares_to_buy > 0:
                cost = shares_to_buy * price
                leftover_cash += (fund - cost)  # ç´¯ç©é›¶é ­
                shares += shares_to_buy
                total_invested += cost
            else:
                leftover_cash += fund  # è‚¡åƒ¹å¤ªé«˜ï¼Œæ•´å€‹æœˆéƒ½ç´¯ç©
            
            # æ¯å¹´ 12 æœˆåº•ï¼šç”¨ç´¯ç©çš„é›¶é ­ä¸€æ¬¡è²·å…¥
            if month == 12:
                extra_shares = int(leftover_cash / price)
                if extra_shares > 0:
                    extra_cost = extra_shares * price
                    shares += extra_shares
                    total_invested += extra_cost
                    leftover_cash -= extra_cost  # å‰©é¤˜çš„é›¶é ­ç¹¼çºŒä¿ç•™
                
        equity_curve.append({'date': date, 'value': shares * price})
    
    equity_df = pd.DataFrame(equity_curve).set_index('date')
    final = equity_df['value'].iloc[-1]
    total_return = (final - total_invested) / total_invested if total_invested > 0 else 0
    
    days = (equity_df.index[-1] - equity_df.index[0]).days
    annualized = (1 + total_return) ** (365/days) - 1 if days > 0 else 0
    daily_ret = equity_df['value'].pct_change().fillna(0)
    sharpe = (daily_ret.mean() * 252) / (daily_ret.std() * np.sqrt(252)) if daily_ret.std() > 0 else 0
    max_dd = ((equity_df['value'] - equity_df['value'].cummax()) / equity_df['value'].cummax()).min()
    
    return {
        'total_invested': total_invested, 'final_value': final, 'total_return': total_return,
        'annualized_return': annualized, 'sharpe_ratio': sharpe, 'max_drawdown': max_dd, 'equity_df': equity_df
    }


def calculate_yearly_lumpsum(df: pd.DataFrame, yearly_amount: float = 600_000):
    close_prices = df['Close'].values
    dates = df.index
    shares = 0
    total_invested = 0
    equity_curve = []
    current_year = None
    
    for i in range(len(df)):
        date = dates[i]
        price = close_prices[i]
        year = date.year
        if current_year != year:
            current_year = year
            shares_to_buy = int(yearly_amount / price)
            if shares_to_buy > 0:
                shares += shares_to_buy
                total_invested += shares_to_buy * price
        equity_curve.append({'date': date, 'value': shares * price})
    
    equity_df = pd.DataFrame(equity_curve).set_index('date')
    final = equity_df['value'].iloc[-1]
    total_return = (final - total_invested) / total_invested if total_invested > 0 else 0
    days = (equity_df.index[-1] - equity_df.index[0]).days
    annualized = (1 + total_return) ** (365/days) - 1 if days > 0 else 0
    daily_ret = equity_df['value'].pct_change().fillna(0)
    sharpe = (daily_ret.mean() * 252) / (daily_ret.std() * np.sqrt(252)) if daily_ret.std() > 0 else 0
    max_dd = ((equity_df['value'] - equity_df['value'].cummax()) / equity_df['value'].cummax()).min()
    
    return {
        'total_invested': total_invested, 'final_value': final, 'total_return': total_return,
        'annualized_return': annualized, 'sharpe_ratio': sharpe, 'max_drawdown': max_dd, 'equity_df': equity_df
    }


def main():
    args = parse_args()
    start_date = pd.Timestamp(args.start)
    end_date = pd.Timestamp(args.end) if args.end else None
    
    # [v6.02] ç•¶çµæŸæ—¥æœŸæ¯”é–‹å§‹æ—¥æœŸæ—©æ™‚ï¼Œè‡ªå‹•ä½¿ç”¨ä»Šå¤©çš„æ—¥æœŸ
    if end_date and end_date < start_date:
        end_date = pd.Timestamp.now().normalize()
        print(f"[Notice] é è¨­çµæŸæ—¥æœŸæ—©æ–¼é–‹å§‹æ—¥æœŸï¼Œå·²è‡ªå‹•èª¿æ•´ç‚ºä»Šå¤©: {end_date.date()}")
    
    print("=" * 70)
    print("V5 DCA + AI Hybrid ç„¡æ¿¾ç¶²å›æ¸¬")
    print("(No Filter Backtest)")
    print("=" * 70)
    print(f"  ğŸ“… å›æ¸¬é–‹å§‹æ—¥æœŸ: {start_date.date()}")
    print(f"  ğŸ“… å›æ¸¬çµæŸæ—¥æœŸ: {end_date.date() if end_date else 'æœ€æ–°è³‡æ–™'}")
    # [v6.0] LSTM å·²ç§»é™¤
    
    os.makedirs(RESULTS_PATH, exist_ok=True)
    
    print("\n[Model] Loading V5 models...")
    buy_model = PPO.load(os.path.join(V5_MODELS_PATH, 'ppo_buy_twii_final.zip'))
    sell_model = PPO.load(os.path.join(V5_MODELS_PATH, 'ppo_sell_twii_final.zip'))
    
    print("\n[Data] Loading data...")
    import ptrl_hybrid_system as hybrid
    
    # [v6.0] ä¸å†è¼‰å…¥ LSTM æ¨¡å‹ï¼Œç›´æ¥è¨ˆç®—ç‰¹å¾µ
    print("  [Compute] è¨ˆç®—ç‰¹å¾µ...")
    twii_raw = hybrid._load_local_twii_data(start_date="2000-01-01")
    twii_full_df = hybrid.calculate_features(twii_raw, twii_raw, ticker="^TWII", use_cache=False)
    
    twii_backtest_df = twii_full_df[twii_full_df.index >= start_date]
    if end_date: twii_backtest_df = twii_backtest_df[twii_backtest_df.index <= end_date]
    
    # [v6.02] æ–°å¢è³‡æ–™å¯ç”¨æ€§æª¢æŸ¥
    if len(twii_backtest_df) == 0:
        print(f"\n[Error] æ²’æœ‰æ‰¾åˆ°æŒ‡å®šæ—¥æœŸç¯„åœå…§çš„è³‡æ–™ï¼")
        print(f"  æŒ‡å®šç¯„åœ: {start_date.date()} ~ {end_date.date() if end_date else 'æœ€æ–°'}")
        print(f"  æœ¬åœ°è³‡æ–™ç¯„åœ: {twii_full_df.index[0].date()} ~ {twii_full_df.index[-1].date()}")
        print(f"\nğŸ’¡ æç¤º: è«‹åŸ·è¡Œ 'python update_twii_data.py' æ›´æ–°æœ¬åœ°è³‡æ–™ï¼Œæˆ–èª¿æ•´ --start/--end åƒæ•¸ã€‚")
        return
    
    print("\n[Backtest] Running Strategy 1: Shared Pool + 2x Leverage on Drawdown...")
    bt1 = LeveragedSharedPoolBacktester(buy_model, sell_model, YEARLY_CAPITAL)
    m1 = bt1.run(twii_backtest_df, hybrid.FEATURE_COLS)

    print("\n[Backtest] Running Strategy 2: Shared Pool...")
    bt2 = SharedPoolBacktester(buy_model, sell_model, YEARLY_CAPITAL)
    m2 = bt2.run(twii_backtest_df, hybrid.FEATURE_COLS)
    
    print("\n[Benchmark] Calculating benchmarks...")
    dca_bench = calculate_pure_dca(twii_backtest_df, MONTHLY_DCA_BENCHMARK)
    lump_bench = calculate_yearly_lumpsum(twii_backtest_df, YEARLY_CAPITAL)
    
    print("\n" + "=" * 120)
    print("Performance Comparison: Strat 1 (2x Leverage) vs Strat 2 (Shared Pool) vs Benchmarks")
    print("=" * 120)
    print(f"{'Metric':<20} {'Strat 1 (2x Lev)':>22} {'Strat 2 (Shared)':>22} {'Pure DCA (50k)':>20} {'Yearly Lump Sum':>20}")
    print("-" * 120)
    print(f"{'Total Invested':<20} ${m1['total_invested']:>20,.0f} ${m2['total_invested']:>20,.0f} ${dca_bench['total_invested']:>18,.0f} ${lump_bench['total_invested']:>18,.0f}")
    print(f"{'Final Value':<20} ${m1['final_value']:>20,.0f} ${m2['final_value']:>20,.0f} ${dca_bench['final_value']:>18,.0f} ${lump_bench['final_value']:>18,.0f}")
    print(f"{'Total Return':<20} {m1['total_return']*100:>21.2f}% {m2['total_return']*100:>21.2f}% {dca_bench['total_return']*100:>19.2f}% {lump_bench['total_return']*100:>19.2f}%")
    print(f"{'Annualized Return':<20} {m1['annualized_return']*100:>21.2f}% {m2['annualized_return']*100:>21.2f}% {dca_bench['annualized_return']*100:>19.2f}% {lump_bench['annualized_return']*100:>19.2f}%")
    print(f"{'Sharpe Ratio':<20} {m1['sharpe_ratio']:>22.2f} {m2['sharpe_ratio']:>22.2f} {dca_bench['sharpe_ratio']:>20.2f} {lump_bench['sharpe_ratio']:>20.2f}")
    print(f"{'Max Drawdown':<20} {m1['max_drawdown']*100:>21.2f}% {m2['max_drawdown']*100:>21.2f}% {dca_bench['max_drawdown']*100:>19.2f}% {lump_bench['max_drawdown']*100:>19.2f}%")
    print("-" * 120)
    print(f"{'DCA Buys':<20} {m1['dca_buys']:>22} {m2['dca_buys']:>22}")
    print(f"{'AI Trades':<20} {m1['total_trades']:>22} {m2['total_trades']:>22}")
    print(f"{'AI Win Rate':<20} {m1['win_rate']*100:>21.1f}% {m2['win_rate']*100:>21.1f}%")
    print("-" * 120)
    # Strategy 1 å°ˆå±¬æ§“æ¡¿çµ±è¨ˆ
    print(f"{'2x Leverage Events':<20} {m1.get('leverage_events', 0):>22}")
    print(f"{'2x Leverage Buys':<20} {m1.get('leverage_2x_buys', 0):>22}")
    if m1.get('leverage_periods'):
        print(f"{'Leverage Periods':<20}")
        for start_dt, end_dt in m1['leverage_periods']:
            print(f"                     ğŸ“… {start_dt.strftime('%Y-%m-%d')} ~ {end_dt.strftime('%Y-%m-%d')}")
    print("=" * 120)
    
    # Charts (Updated: 3 Subplots)
    fig, axes = plt.subplots(3, 1, figsize=(16, 18))
    
    # 1. Equity
    ax1 = axes[0]
    ax1.plot(m1['equity_df'].index, m1['equity_df']['value'], label='Strat 1 (2x Leverage)', color='blue', linewidth=2)
    ax1.plot(m2['equity_df'].index, m2['equity_df']['value'], label='Strat 2 (Shared)', color='purple', linewidth=2)
    
    # æ¨™ç¤º 2x æ§“æ¡¿æœŸé–“ (èƒŒæ™¯è‰²)
    if m1.get('leverage_periods'):
        for start_dt, end_dt in m1['leverage_periods']:
            ax1.axvspan(start_dt, end_dt, alpha=0.15, color='red', label='2x Leverage Period' if start_dt == m1['leverage_periods'][0][0] else '') 
    ax1.plot(dca_bench['equity_df'].index, dca_bench['equity_df']['value'], label='Pure DCA', color='orange', linewidth=1.5, linestyle='--')
    ax1.plot(lump_bench['equity_df'].index, lump_bench['equity_df']['value'], label='Yearly Lump', color='gray', linewidth=1.5, alpha=0.7)
    date_range_str = f"{twii_backtest_df.index[0].strftime('%Y-%m-%d')} ~ {twii_backtest_df.index[-1].strftime('%Y-%m-%d')}"
    ax1.set_title(f'V4 DCA+AI Hybrid Strategies Comparison ({date_range_str})', fontsize=14)
    ax1.set_ylabel('Portfolio Value ($)')
    ax1.legend(loc='upper left')
    ax1.grid(True, alpha=0.3)
    
    price_slice = twii_backtest_df['Close']
    
    # 2. Strat 1 Signals
    ax2 = axes[1]
    ax2.plot(price_slice.index, price_slice.values, label='^TWII', color='black', linewidth=1)
    # æ¨™ç¤º 2x æ§“æ¡¿æœŸé–“
    if m1.get('leverage_periods'):
        for start_dt, end_dt in m1['leverage_periods']:
            ax2.axvspan(start_dt, end_dt, alpha=0.15, color='red', label='2x Period' if start_dt == m1['leverage_periods'][0][0] else '')
    
    if bt1.dca_buy_signals:
        # åˆ†é–‹ 1x å’Œ 2x DCA è²·å…¥
        dca_1x = [(d, p) for d, p, s, lev in bt1.dca_buy_signals if lev == 1.0]
        dca_2x = [(d, p) for d, p, s, lev in bt1.dca_buy_signals if lev > 1.0]
        if dca_1x:
            d1x, p1x = zip(*dca_1x)
            ax2.scatter(d1x, p1x, marker='o', color='cyan', s=30, label='S1: DCA Buy (1x)', alpha=0.6)
        if dca_2x:
            d2x, p2x = zip(*dca_2x)
            ax2.scatter(d2x, p2x, marker='o', color='orange', s=50, label='S1: DCA Buy (2x)', alpha=0.8)
    if bt1.ai_buy_signals:
        # åˆ†é–‹ 1x å’Œ 2x AI è²·å…¥
        ai_1x = [s for s in bt1.ai_buy_signals if s.get('leverage', 1) == 1.0]
        ai_2x = [s for s in bt1.ai_buy_signals if s.get('leverage', 1) > 1.0]
        if ai_1x:
            ax2.scatter([s['date'] for s in ai_1x], [s['price'] for s in ai_1x], 
                       marker='^', color='blue', s=80, label='S1: AI Buy (1x)')
        if ai_2x:
            ax2.scatter([s['date'] for s in ai_2x], [s['price'] for s in ai_2x], 
                       marker='^', color='red', s=100, label='S1: AI Buy (2x)')
    if bt1.ai_sell_signals:
        ai_sell_dates = [s['date'] for s in bt1.ai_sell_signals]
        ai_sell_prices = [s['price'] for s in bt1.ai_sell_signals]
        ax2.scatter(ai_sell_dates, ai_sell_prices, marker='v', color='green', s=80, label='S1: AI Sell')
    ax2.set_title('Strategy 1 (Shared Pool + 2x Leverage on Drawdown) Trade Signals', fontsize=14)
    ax2.set_ylabel('Price')
    ax2.legend(loc='upper left', fontsize=8)
    ax2.grid(True, alpha=0.3)
    
    # 3. Strat 2 Signals
    ax3 = axes[2]
    ax3.plot(price_slice.index, price_slice.values, label='^TWII', color='black', linewidth=1)
    if bt2.dca_buy_signals:
        dca_dates, dca_prices, _ = zip(*bt2.dca_buy_signals)
        ax3.scatter(dca_dates, dca_prices, marker='o', color='orange', s=30, label='S2: DCA Buy', alpha=0.6)
    if bt2.ai_buy_signals:
        ai_buy_dates = [s['date'] for s in bt2.ai_buy_signals]
        ai_buy_prices = [s['price'] for s in bt2.ai_buy_signals]
        ax3.scatter(ai_buy_dates, ai_buy_prices, marker='^', color='purple', s=80, label='S2: AI Buy')
    if bt2.ai_sell_signals:
        ai_sell_dates = [s['date'] for s in bt2.ai_sell_signals]
        ai_sell_prices = [s['price'] for s in bt2.ai_sell_signals]
        ax3.scatter(ai_sell_dates, ai_sell_prices, marker='v', color='green', s=80, label='S2: AI Sell')
    ax3.set_title('Strategy 2 (Shared Pool) Trade Signals', fontsize=14)
    ax3.set_ylabel('Price')
    ax3.legend(loc='upper left')
    ax3.grid(True, alpha=0.3)
    
    plt.tight_layout()
    start_str = twii_backtest_df.index[0].strftime('%Y%m%d')
    end_str = twii_backtest_df.index[-1].strftime('%Y%m%d')
    save_path = os.path.join(RESULTS_PATH, f'backtest_comparison_{start_str}_{end_str}.png')
    plt.savefig(save_path, dpi=150, bbox_inches='tight')
    print(f"\n[Output] Chart: {save_path}")
    plt.close()
    
    metrics_df = pd.DataFrame({
        'Metric': ['Total_Invested', 'Final_Value', 'Total_Return_Pct', 'Annualized_Return_Pct', 'Sharpe_Ratio', 'Max_Drawdown_Pct', 'DCA_Buys', 'AI_Trades', 'AI_Win_Rate_Pct'],
        'Strat1_Split': [m1['total_invested'], m1['final_value'], m1['total_return']*100, m1['annualized_return']*100, m1['sharpe_ratio'], m1['max_drawdown']*100, m1['dca_buys'], m1['total_trades'], m1['win_rate']*100],
        'Strat2_Shared': [m2['total_invested'], m2['final_value'], m2['total_return']*100, m2['annualized_return']*100, m2['sharpe_ratio'], m2['max_drawdown']*100, m2['dca_buys'], m2['total_trades'], m2['win_rate']*100],
        'Pure_DCA': [dca_bench['total_invested'], dca_bench['final_value'], dca_bench['total_return']*100, dca_bench['annualized_return']*100, dca_bench['sharpe_ratio'], dca_bench['max_drawdown']*100, 'N/A', 'N/A', 'N/A'],
        'Yearly_Lump': [lump_bench['total_invested'], lump_bench['final_value'], lump_bench['total_return']*100, lump_bench['annualized_return']*100, lump_bench['sharpe_ratio'], lump_bench['max_drawdown']*100, 'N/A', 'N/A', 'N/A']
    })
    metrics_path = os.path.join(RESULTS_PATH, f'metrics_comparison_{start_str}_{end_str}.csv')
    metrics_df.to_csv(metrics_path, index=False, encoding='utf-8-sig')
    print(f"[Output] Metrics: {metrics_path}")
    
    if bt2.trades:
        trades_df = pd.DataFrame(bt2.trades)
        trades_path = os.path.join(RESULTS_PATH, f'trades_strat2_{start_str}_{end_str}.csv')
        trades_df.to_csv(trades_path, index=False)
        print(f"[Output] Strat 2 Trades: {trades_path}")

    # New Exports
    if bt1.trades:
        trades1_df = pd.DataFrame(bt1.trades)
        trades1_path = os.path.join(RESULTS_PATH, f'trades_strat1_{start_str}_{end_str}.csv')
        trades1_df.to_csv(trades1_path, index=False)
        print(f"[Output] Strat 1 Trades: {trades1_path}")

    if bt1.daily_confidence:
        conf1_df = pd.DataFrame(bt1.daily_confidence)
        conf1_path = os.path.join(RESULTS_PATH, f'daily_confidence_strat1_{start_str}_{end_str}.csv')
        conf1_df.to_csv(conf1_path, index=False)
        print(f"[Output] Strat 1 Daily Confidence: {conf1_path}")

    if bt2.daily_confidence:
        conf2_df = pd.DataFrame(bt2.daily_confidence)
        conf2_path = os.path.join(RESULTS_PATH, f'daily_confidence_strat2_{start_str}_{end_str}.csv')
        conf2_df.to_csv(conf2_path, index=False)
        print(f"[Output] Strat 2 Daily Confidence: {conf2_path}")

    # =========================================================================
    # æ–°å¢ï¼šStrategy 2 æ¯æ—¥æ“ä½œå ±å‘Š (Console + CSV + PNG)
    # =========================================================================
    
    # 1. Console è¼¸å‡ºæœ€è¿‘ 30 å¤©
    print_daily_action_report(bt2.daily_action_summary, last_n_days=30, strategy_name="Strategy 2 - Shared Pool")
    
    # 2. Daily Action CSV (ä¸€å¤©ä¸€ç­†)
    if bt2.daily_action_summary:
        action_df = pd.DataFrame(bt2.daily_action_summary)
        action_path = os.path.join(RESULTS_PATH, f'daily_action_strat2_{start_str}_{end_str}.csv')
        action_df.to_csv(action_path, index=False, encoding='utf-8-sig')
        print(f"[Output] Daily Action CSV: {action_path}")
    
    # 2.5 Open Positions CSV (æœªå¹³å€‰æŒå€‰ï¼Œä¾› intraday è…³æœ¬ä½¿ç”¨)
    if bt2.open_positions:
        pos_df = pd.DataFrame(bt2.open_positions)
        pos_path = os.path.join(RESULTS_PATH, f'open_positions_strat2_{start_str}_{end_str}.csv')
        pos_df.to_csv(pos_path, index=False, encoding='utf-8-sig')
        print(f"[Output] Open Positions CSV: {pos_path}")
        print(f"         æœªå¹³å€‰ AI æŒå€‰: {len(bt2.open_positions)} ç­†")
    else:
        print(f"[Info] Strat 2 ç„¡æœªå¹³å€‰ AI æŒå€‰")
    
    # 3. Daily Timeline Chart
    create_daily_timeline_chart(bt2.daily_action_summary, twii_backtest_df, 
                                 os.path.join(RESULTS_PATH, f'daily_timeline_strat2_{start_str}_{end_str}.png'),
                                 leverage_periods=None)
    
    # =========================================================================
    # æ–°å¢ï¼šStrategy 1 æ¯æ—¥æ“ä½œå ±å‘Š (Console + CSV + PNG) - å«æ§“æ¡¿è³‡è¨Š
    # =========================================================================
    
    # 1. Console è¼¸å‡ºæœ€è¿‘ 30 å¤© (Strategy 1)
    print_daily_action_report(bt1.daily_action_summary, last_n_days=30, strategy_name="Strategy 1 - 2x Leverage on Drawdown")
    
    # 2. Daily Action CSV (ä¸€å¤©ä¸€ç­†)
    if bt1.daily_action_summary:
        action1_df = pd.DataFrame(bt1.daily_action_summary)
        action1_path = os.path.join(RESULTS_PATH, f'daily_action_strat1_{start_str}_{end_str}.csv')
        action1_df.to_csv(action1_path, index=False, encoding='utf-8-sig')
        print(f"[Output] Strat 1 Daily Action CSV: {action1_path}")
    
    # 2.5 Open Positions CSV (æœªå¹³å€‰æŒå€‰)
    if bt1.open_positions:
        pos1_df = pd.DataFrame(bt1.open_positions)
        pos1_path = os.path.join(RESULTS_PATH, f'open_positions_strat1_{start_str}_{end_str}.csv')
        pos1_df.to_csv(pos1_path, index=False, encoding='utf-8-sig')
        print(f"[Output] Strat 1 Open Positions CSV: {pos1_path}")
        print(f"         æœªå¹³å€‰ AI æŒå€‰: {len(bt1.open_positions)} ç­†")
    else:
        print(f"[Info] Strat 1 ç„¡æœªå¹³å€‰ AI æŒå€‰")
    
    # 2.6 Leverage Events CSV
    if bt1.leverage_events:
        lev_df = pd.DataFrame(bt1.leverage_events)
        lev_path = os.path.join(RESULTS_PATH, f'leverage_events_strat1_{start_str}_{end_str}.csv')
        lev_df.to_csv(lev_path, index=False, encoding='utf-8-sig')
        print(f"[Output] Leverage Events CSV: {lev_path}")
    
    # 3. Daily Timeline Chart for Strategy 1 (å«æ§“æ¡¿æœŸé–“æ¨™ç¤º)
    create_daily_timeline_chart(bt1.daily_action_summary, twii_backtest_df, 
                                 os.path.join(RESULTS_PATH, f'daily_timeline_strat1_{start_str}_{end_str}.png'),
                                 leverage_periods=m1.get('leverage_periods'))


def print_daily_action_report(daily_summary: list, last_n_days: int = 30, strategy_name: str = ""):
    """åœ¨çµ‚ç«¯æ©Ÿè¼¸å‡ºæœ€è¿‘ N å¤©çš„æ“ä½œå ±å‘Š"""
    if not daily_summary:
        return
    
    print("\n" + "=" * 110)
    print(f"ğŸ“… æ¯æ—¥æ“ä½œå ±å‘Š ({strategy_name}) - æœ€è¿‘ {last_n_days} å¤©")
    print("=" * 110)
    print(f"{'æ—¥æœŸ':<12} {'AIæ“ä½œ':<6} {'åƒ¹æ ¼':>10} {'è²·å…¥ä¿¡å¿ƒ':>10} {'è³£å‡ºä¿¡å¿ƒ':>10} {'2xæ¨¡å¼':>6} {'å‚™è¨»':<35}")
    print("-" * 110)
    
    for row in daily_summary[-last_n_days:]:
        icon = {'BUY': 'âœ…', 'SELL': 'ğŸ”´', 'HOLD': 'â¸ï¸'}.get(row['ai_action'], 'â“')
        date_str = row['date'].strftime('%Y-%m-%d')
        price_str = f"{row['price']:,.0f}"
        
        buy_conf_str = f"{row['ai_buy_conf']*100:.1f}%" if row['ai_buy_conf'] is not None else "-"
        sell_conf_str = f"{row['ai_sell_conf']*100:.1f}%" if row['ai_sell_conf'] is not None else "-"
        
        # æ§“æ¡¿æ¨¡å¼ç‹€æ…‹ (å¦‚æœæœ‰çš„è©±)
        lev_mode = row.get('leveraged_mode', None)
        lev_str = "ğŸ”¥2x" if lev_mode else ("1x" if lev_mode is not None else "-")
        
        print(f"{date_str:<12} {icon} {row['ai_action']:<4} {price_str:>10} {buy_conf_str:>10} {sell_conf_str:>10} {lev_str:>6}  {row['note']:<35}")
    
    print("=" * 110)
    
    # çµ±è¨ˆ
    recent = daily_summary[-last_n_days:]
    total_days = len(recent)
    buy_count = sum(1 for r in recent if r['ai_action'] == 'BUY')
    sell_count = sum(1 for r in recent if r['ai_action'] == 'SELL')
    hold_count = total_days - buy_count - sell_count
    
    # æœ€å¾Œä¸€å¤©çš„ç¸½å€‰æ•¸
    final_total = recent[-1]['total_position_count'] if recent else 0
    final_dca = recent[-1]['dca_position_count'] if recent else 0
    final_ai = recent[-1]['ai_position_count'] if recent else 0
    final_2x = recent[-1].get('positions_2x', 0) if recent else 0
    
    print(f"çµ±è¨ˆ: ç¸½å¤©æ•¸ {total_days} | AIè²·å…¥ {buy_count} å€‰ | AIè³£å‡º {sell_count} å€‰ | HOLD {hold_count} å¤©")
    print(f"æœ€çµ‚æŒå€‰: ç¸½ {final_total} å€‰ (DCA {final_dca} + AI {final_ai}) | å…¶ä¸­ 2x æ§“æ¡¿: {final_2x} å€‰")
    print("=" * 110)


def create_daily_timeline_chart(daily_summary: list, price_df: pd.DataFrame, save_path: str, leverage_periods: list = None):
    """ç”¢ç”Ÿæ¯æ—¥æ“ä½œæ™‚é–“ç·šåœ–è¡¨ï¼šåƒ¹æ ¼èµ°å‹¢+è²·è³£é»ã€ç¸½å€‰æ•¸æ™‚åº"""
    if not daily_summary:
        return
    
    summary_df = pd.DataFrame(daily_summary)
    summary_df.set_index('date', inplace=True)
    
    fig, axes = plt.subplots(2, 1, figsize=(16, 10), gridspec_kw={'height_ratios': [3, 1]})
    
    # 1. åƒ¹æ ¼èµ°å‹¢ + AI/DCA è²·è³£é»æ¨™è¨˜ (ä¸é¡¯ç¤ºä¿¡å¿ƒåº¦)
    ax1 = axes[0]
    
    # æ¨™ç¤º 2x æ§“æ¡¿æœŸé–“ (èƒŒæ™¯è‰²)
    if leverage_periods:
        for idx, (start_dt, end_dt) in enumerate(leverage_periods):
            ax1.axvspan(start_dt, end_dt, alpha=0.15, color='red', 
                       label='2x Leverage Period' if idx == 0 else '')
    
    ax1.plot(price_df.index, price_df['Close'], color='black', linewidth=1, label='^TWII')
    
    # AI BUY - å€åˆ† 1x å’Œ 2x
    buy_mask = summary_df['ai_action'] == 'BUY'
    if buy_mask.any():
        buy_data = summary_df[buy_mask]
        if 'current_leverage' in buy_data.columns:
            buy_1x = buy_data[buy_data['current_leverage'] == 1.0]
            buy_2x = buy_data[buy_data['current_leverage'] > 1.0]
            if len(buy_1x) > 0:
                ax1.scatter(buy_1x.index, buy_1x['price'], marker='^', color='green', s=80, label='AI BUY (1x)', zorder=5)
            if len(buy_2x) > 0:
                ax1.scatter(buy_2x.index, buy_2x['price'], marker='^', color='red', s=100, label='AI BUY (2x)', zorder=6)
        else:
            ax1.scatter(buy_data.index, buy_data['price'], marker='^', color='green', s=80, label='AI BUY', zorder=5)
    
    # AI SELL
    sell_mask = summary_df['ai_action'] == 'SELL'
    if sell_mask.any():
        sell_dates = summary_df[sell_mask].index
        sell_prices = summary_df[sell_mask]['price']
        ax1.scatter(sell_dates, sell_prices, marker='v', color='purple', s=80, label='AI SELL', zorder=5)
    
    # DCA BUY (dca_position_count å¢åŠ æ™‚)
    dca_positions = summary_df['dca_position_count'].values
    dca_increase = [False] + [dca_positions[i] > dca_positions[i-1] for i in range(1, len(dca_positions))]
    dca_buy_dates = summary_df.index[dca_increase]
    dca_buy_prices = summary_df.loc[dca_buy_dates, 'price']
    if len(dca_buy_dates) > 0:
        ax1.scatter(dca_buy_dates, dca_buy_prices, marker='o', color='blue', s=60, label='DCA BUY', zorder=4, alpha=0.7)
    
    title_suffix = " (with 2x Leverage on Drawdown)" if leverage_periods else ""
    ax1.set_title(f'AI & DCA Trading Signals{title_suffix}', fontsize=14)
    ax1.set_ylabel('Price')
    ax1.legend(loc='upper left', fontsize=8)
    ax1.grid(True, alpha=0.3)
    
    # 2. å€‰æ•¸æ™‚åºåœ– (å †ç–Šå€åŸŸåœ–: DCA + AI)
    ax2 = axes[1]
    
    # æ¨™ç¤º 2x æ§“æ¡¿æœŸé–“ (èƒŒæ™¯è‰²)
    if leverage_periods:
        for idx, (start_dt, end_dt) in enumerate(leverage_periods):
            ax2.axvspan(start_dt, end_dt, alpha=0.15, color='red')
    
    dates = summary_df.index
    dca_pos = summary_df['dca_position_count'].values
    ai_pos = summary_df['ai_position_count'].values
    total_pos = summary_df['total_position_count'].values
    
    # å †ç–Šå€åŸŸåœ–
    ax2.fill_between(dates, 0, dca_pos, alpha=0.6, color='blue', label='DCA å€‰')
    ax2.fill_between(dates, dca_pos, total_pos, alpha=0.6, color='green', label='AI å€‰')
    ax2.plot(dates, total_pos, color='black', linewidth=1.5, label='ç¸½å€‰æ•¸')
    
    # å¦‚æœæœ‰ 2x å€‰ä½è³‡è¨Šï¼Œä¹Ÿé¡¯ç¤º
    if 'positions_2x' in summary_df.columns:
        pos_2x = summary_df['positions_2x'].values
        ax2.plot(dates, pos_2x, color='red', linewidth=1.5, linestyle='--', label='2x å€‰æ•¸')
    
    # æ¨™ç¤ºæœ€çµ‚å€‰æ•¸
    final_total = total_pos[-1]
    final_dca = dca_pos[-1]
    final_ai = ai_pos[-1]
    final_2x = summary_df['positions_2x'].iloc[-1] if 'positions_2x' in summary_df.columns else 0
    
    label_text = f'ç¸½{final_total}å€‰\n(DCA{final_dca}+AI{final_ai})'
    if final_2x > 0:
        label_text += f'\n[2x:{final_2x}]'
    
    ax2.annotate(label_text, 
                (dates[-1], final_total), 
                textcoords="offset points", xytext=(10, 0), 
                ha='left', fontsize=10, fontweight='bold',
                bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))
    
    ax2.set_ylabel('Position Count (å€‰æ•¸)')
    ax2.set_xlabel('Date')
    ax2.legend(loc='upper left')
    ax2.grid(True, alpha=0.3)
    ax2.set_ylim(0, max(total_pos) * 1.15)
    
    plt.tight_layout()
    plt.savefig(save_path, dpi=150, bbox_inches='tight')
    print(f"[Output] Daily Timeline Chart: {save_path}")
    plt.close()


if __name__ == "__main__":
    main()
